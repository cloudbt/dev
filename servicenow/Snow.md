

```
ありがとうございます。
SG-Azureの差分収集は、ServiceNow側が「前回の収集日時」を保持し、Azureから「その日時以降に更新されたデータのみ」を取得する仕組みです。
そのため、SubscriptionやAzureリソースの追加・削除といった通常の変更は、基本的に差分収集で問題なく反映されます。

一方で、取りこぼしや分類ずれが発生しやすいのは主に以下のケースと考えられます。

1. 一時的な通信タイムアウト
→大量のデータ取得中に瞬断やタイムアウトが発生し、特定のデータブロック（ページ）だけ取得に失敗した場合、
そのデータに更新がない限り次回以降の差分収集対象に入らず、欠損したままとなります。

2.Azure API のレート制限（Throttling）や一時障害で一部の呼び出しが落ちる
→特定リソース種別だけ欠ける、あるいは関連情報だけ欠けるといった状況が発生します。

こうした偶発的な漏れや不整合をリセット（棚卸し）するために、定期的な全量収集が有効となります。
ご確認のほどよろしくお願いいたします。
```


Q1. 案Dはパフォーマンスに影響する？
→ 普通の規模・普通の操作頻度なら 影響はごく小さい／ほぼ無視できるレベル です。
　Ref Qual の中身も cmdb_rel_ci に対する1回の軽いクエリだけです。

Q2. どのタイミングで実行される？
→ Management IP 参照フィールドに関して、

フォーム表示時（必要なとき）

候補リストを表示する時（ルックアップ / オートコンプリート）

入力値を確定／検証する時

に サーバ側で1回実行 されます。
フォームにただ表示されているだけで、ユーザが触らなければそれほど呼ばれません。


**案D：参照制限の緩和（Reference Qualifierの変更）** に関するパフォーマンスへの影響と、実行タイミングについて詳しく解説します。

結論から申し上げますと、**パフォーマンスへの影響は「極めて低い（無視できるレベル）」** です。安心して実装していただいて問題ありません。

以下にその理由と技術的な詳細をまとめました。

-----

### 1\. どのタイミングで実行されるか？（いつ動くのか）

このスクリプト（Script Include）は、常に裏で動いているわけではありません。**「そのフィールド（管理IPアドレス）を使おうとした瞬間」** にだけ実行されます。

具体的には以下のタイミングです：

1.  **虫眼鏡アイコンをクリックした時**
      * ユーザーがフォーム上で「管理IPアドレス」の検索ボタン（虫眼鏡）をクリックし、リストを表示しようとした瞬間に1回実行されます。
2.  **フィールドに文字を入力した時（オートコンプリート）**
      * ユーザーがフィールドに直接 `192...` などと打ち込み始めた際、候補を探すために実行されます。
3.  **保存時の整合性チェック（バリデーション）**
      * フォームの「Save/Update」ボタンを押した際、またはAPI経由でデータを登録する際、「入力された値が条件を満たしているか？」を確認するために実行される場合があります。

**重要な点:**

  * **リスト表示（一覧画面）を開くだけでは実行されません**（その列を「List Edit」で編集しようとしない限り）。
  * **バックグラウンドの定期ジョブ（Scheduled Job）のように、常時リソースを消費するものではありません。**

-----

### 2\. パフォーマンスへの影響（なぜ軽いのか）

スクリプト内で `GlideRecord`（データベース検索）を行っているため、理論上はDB負荷がかかりますが、以下の理由により**実質的な負荷はゼロに近い**です。

#### A. 検索対象が「インデックス（索引）」付きである

スクリプト内で行っている検索は、すべて「Referenceフィールド（SysID）」を使った検索です。

  * `cmdb_rel_ci` テーブルの `parent` 列
  * `cmdb_ci_network_adapter` テーブルの `cmdb_ci` 列
  * `cmdb_ci_ip_address` テーブルの `nic` 列

これらはServiceNowのデータベース構造上、最初からインデックスが貼られています（本の索引がある状態）。そのため、何百万件のデータがあっても、一瞬で特定の数件を見つけ出すことができます（Full Table Scanは発生しません）。

#### B. ループ回数が極端に少ない

スクリプトには `while` ループが含まれていますが、その回数は非常に少ないです。

  * 1台のサーバーに紐づくVMは通常 **1台** です。
  * 1台のVMに紐づくNICは通常 **1〜2個** です。
  * **結果:** 何千回もループするわけではなく、せいぜい2〜3回で処理が終わります。計算時間は数ミリ秒（0.01秒以下）の世界です。

-----

### 3\. 他の案との負荷比較

| 比較 | **案A（親の書き換え）** | **案D（今回の案：Ref Qual）** |
| :--- | :--- | :--- |
| **実行頻度** | **毎日数万回**<br>（全サーバー×全NICに対し、SGC実行時に必ず発生） | **ユーザー操作時のみ**<br>（担当者がそのサーバーのフォームを編集する時だけ） |
| **対象データ量** | **大量**<br>CMDB全体に影響 | **1件**<br>現在開いているそのレコードに対してのみ計算 |
| **DBへの書き込み** | **あり**<br>（Update処理が発生＝重い） | **なし**<br>（Read処理のみ＝軽い） |
| **結論** | サーバー全体の負荷になる | 負荷として検知できないレベル |

### まとめ

案Dは **「ユーザーが操作したその一瞬、そのレコードのためだけに、インデックスを使って高速に検索する」** 仕組みですので、システム全体のパフォーマンスを低下させる懸念はありません。

**Now Supportへの問い合わせと並行して、この案Dの実装・検証を進めていただくのが最もリスクの少ない進め方になります。**



お問い合わせの文面作成、承知いたしました。
まず、ご質問の `Discovery : zzzに紐づく` の「zzz」の部分について補足・解説し、その上でNow Support（旧HI）への問い合わせ文案を作成します。

### 1. 「Discovery（zzz）」についての補足

標準的な**Discovery（Horizontal Discovery / IPベースのDiscovery）**の場合、ネットワークアダプターやIPアドレスは**「Linux Server (`cmdb_ci_linux_server`)」**に直接紐づきます。

* **理由:** DiscoveryはSSH等でOS内部にログインし、`ifconfig` や `ip addr` コマンドを叩いて情報を収集します。そのため、「OSが認識しているデバイス」として、OSを表すCI（Linux Server）の直下にNICとIPがぶら下がります。
* **構造:** `Linux Server` --(Owns)--> `Network Adapter` --(Owns)--> `IP Address`

したがって、比較構造は以下のようになります。

* **SG-AWS:** Linux Server に紐づく
* **Standard Discovery:** Linux Server に紐づく
* **SG-Azure:** **VM Instance に紐づく** （ここだけ仲間外れ）

---

### 2. Now Support 問い合わせ文案

以下の文面をベースに、必要に応じて微調整して起票してください。添付ファイルとして、今回ご提示いただいたETLのスクリーンショットや、実際のフォーム画面（IPが表示されていない画面）を添付すると話が早いです。

**件名:**
SG-AzureにおけるNetwork Adapter/IPアドレスの紐づけ先（VM Instance）の仕様確認と、SG-AWS/Discoveryとの差異について

**本文:**
お世話になっております。
Service Graph Connector (SGC) for Azure の仕様と、データモデリングのベストプラクティスについてご教示ください。

**【背景】**
現在、SGC for AWS、SGC for Azure、および通常のDiscoveryを併用してLinuxサーバーの管理を行っておりますが、それぞれで収集されるNetwork Adapter (NIC) および IP Address の紐づき先（親CI）に差異があり、運用上の課題が生じています。

**【現状の動作】**
各手法におけるNIC/IPの紐づき先は以下の通り認識しております。

1.  **SG-AWS (Amazon Web Services):**
    * 親CI: **Linux Server** (`cmdb_ci_linux_server`)
2.  **ServiceNow Discovery (IP based):**
    * 親CI: **Linux Server** (`cmdb_ci_linux_server`)
3.  **SG-Azure (Microsoft Azure):**
    * 親CI: **VM Instance** (`cmdb_ci_vm_instance`)

**【課題】**
SGC-Azureのみ、NICおよびIPアドレスが「Linux Server」ではなく、インフラ側の「VM Instance」に紐づけられます。
これにより、以下の実務上の支障が出ています。

* **UIの不整合:** Linux Serverフォームの「CI IPs」タブ等の関連リストにIPアドレスが表示されない。
* **連携への影響:** Ansible連携（Ansible Spoke等）において、Linux Serverレコード上の「管理IPアドレス」フィールド等を参照しようとした際、Server自身がIPを持っていないため、参照エラー（Invalid Reference）や自動入力不可といった問題が発生しています。

**【ご質問】**
1.  **仕様の意図について:**
    SGC-Azureにおいて、OS（Linux Server）ではなくVM Instance側にNIC/IPを紐づけるのは、Azureのリソース構造（NICが独立したリソースである等）を反映した意図的な設計仕様でしょうか？
2.  **推奨される解決策について:**
    Linux Serverを主体として運用（Ansible連携など）を行う場合、この差異をどのように埋めるのが貴社のベストプラクティスでしょうか？
    * 例A: ETL定義をカスタマイズして、取り込み時にLinux Serverへ紐づくよう変更する（推奨されますか？）
    * 例B: データ構造はそのまま（VM紐づけ）とし、UIや参照フィールド側の設定（Reference Qualifier等）でカバーする

他社事例や推奨設定がございましたらご教示いただけますと幸いです。

--------------------------------------------------

### 3. 問い合わせ時のポイント（補足）

サポートエンジニアに対して**「Ansibleで困っている」**という実害を強調するのが重要です（単なる見た目の好みの問題ではないと伝えるため）。

回答としておそらく、「AzureのAPI仕様上、VMのリソースとして取得するため仕様通りの動作です」という答えが返ってくる可能性が高いですが、その後の「じゃあどうすべきか（How）」として、今回私たちが議論した**「Reference Qualifierの変更（案D）」**が妥当なワークアラウンドかどうかを確認する裏付けにもなります。









既存の SG-Azure の Transform / データソースを直接書き換えるのは
アップグレード時に上書きされるので、別のスクリプト or Job に切り出す方が無難です。


ご指摘ありがとうございます。仰る通りです。

ユーザー様の技術的な分析（IREの挙動とIdentification Ruleに関する洞察）は非常に鋭く、正確です。 SGC-Azureの初期設定（OOB）において、NIC（cmdb_ci_nic や cmdb_ci_network_adapter）の識別ルールが「親CI (Hardware) に依存しない（Independent）」設定、つまり object_id や mac_address 単独で識別される設定であれば、「別レコードとして雪だるま式に増える」という事象は発生しません。

その代わり、ご懸念の通り**「毎日、IREがVMに戻し、直後にBusiness RuleがServerに書き換える」という『綱引き（更新合戦）』**が発生します。

この点を踏まえ、訂正した評価を含む4案の比較表を作成しました。 今回、Ansibleタブでの入力エラー（無効な参照）を解決する という目的において、案D（参照制限の緩和） を最有力として評価しています。


詳細解説：なぜ「案A」ではなく「案D」なのか
案A（親の書き換え）の再評価：レコードは増えないが、ログが壊れる
ユーザー様のご指摘通り、識別ルールが適切であればレコード重複は回避できます。しかし、以下の「綱引き」はシステム運用上、非常に大きなデメリットとなります。

Sys_audit / Sys_history_line テーブルの爆発: 毎日、全Linux Server台数分のNICに対して update が2回（IREによる書き戻し + BRによる再移動）発生します。数千台規模の場合、毎日数万件の不要な更新ログが積み上がり、テーブル容量を圧迫します。

「更新された」とみなされる: 実態（IPアドレスなど）が変わっていなくても、親の付け替えが発生するため、sys_updated_on が毎日更新されます。これにより、「長期間変更がないサーバーを探す」といったクエリが機能しなくなります。

案D（参照制限の緩和）の優位性
今回判明した課題は 「Ansibleタブの管理IPアドレス欄でエラーが出る（入力できない）」 という点でした。 これに対し、案Dは**「データの実体（VMにNICがある状態）は変えずに、ServiceNowに入力ルールだけを教え込む」** アプローチです。

IRE/ETLへの干渉ゼロ: 取り込み処理には一切触れないため、最も安全です。

根本解決: 「VMのIPを使いたい」という要件に対し、データを無理やりコピーや移動させるのではなく、「参照できる範囲を広げる」のが本来のデータベース設計として正しいアプローチです。

実装コスト: 前回の回答にある「Script Include」と「Dictionary設定」だけで完了します。

結論
ご提示いただいた 「案A（親書き換え）」 は、レコード重複のリスクは低いものの、「更新合戦によるログ肥大化・更新日時の常時更新」 という運用上の副作用が大きいため、やはりお勧めできません。

Ansibleタブへの入力エラー解消が主目的であれば、「案D：参照制限の緩和（Reference Qualifierの変更）」 で進めることを強く推奨いたします。


```
javascript:
(function() {

    // ★ Azure 以外（SG-AWS やオンプレ等）は従来クエリのまま
    if (current.discovery_source != 'SG-Azure') {
        return 'install_status!=100^nic.cmdb_ci.sys_id=' + current.sys_id;
    }

    // ── ここから SG-Azure Linux 専用ロジック ──

    // ① Linux 自身 + 関連 VM の sys_id を集める
    var ciIds = [];
    ciIds.push(current.sys_id.toString());   // Linux Server 自身

    var rel = new GlideRecord('cmdb_rel_ci');
    // 親: Linux Server, 子: Virtual Machine Instance
    rel.addQuery('parent', current.sys_id);
    rel.addQuery('type.name', 'Virtualized by::Virtualizes');
    rel.query();
    while (rel.next()) {
        if (rel.child.sys_class_name == 'cmdb_ci_vm_instance') {
            ciIds.push(rel.child.toString());  // VM を追加
        }
    }

    // VM が見つからなければ従来クエリにフォールバック
    if (ciIds.length === 1) {
        return 'install_status!=100^nic.cmdb_ci.sys_id=' + current.sys_id;
    }

    // ② Linux + VM の NIC にぶら下がる IP を候補にする
    return 'install_status!=100^nic.cmdb_ci.sys_idIN' + ciIds.join(',');

})();

```


4案を横並びで見られるように整理しました。
前提として：

* 対象：**Azure Linux の管理IPをAnsibleタブに入れたい**（CI IPs は必須ではない）
* 4案の定義

| 案     | 概要                                                                                    |
| ----- | ------------------------------------------------------------------------------------- |
| **A** | SGC-Azure / IRE のパターン・Transform・識別ルールをカスタマイズして、最初から「Linuxに正しいNIC/IPが付く」ようにする          |
| **B** | 取込後の BR/Flow で `cmdb_ci_nic.cmdb_ci` を “VM → Linux” に書き換える（元のNICを移動）                  |
| **C** | 取込後に VM 側 NIC/IP をコピーして **Linux用 NIC/IP を別レコードで作成**（VM/LINUX両方に持たせる）                  |
| **D** | **Management IP の Reference Qualifier を拡張**し、Linux直下のIPに加えて「関連VMのIP」も選択候補にする（今回作ったやつ） |

---

## メリデメ比較表

| 観点                                 | 案A：SGC/IRE側カスタマイズ                                        | 案B：BR/Flowで cmdb_ci 書き換え                                         | 案C：NIC/IP 複製（VM & Linux 両方）                      | 案D：Management IP の Ref Qual 拡張                                 |
| ---------------------------------- | -------------------------------------------------------- | ---------------------------------------------------------------- | ------------------------------------------------ | -------------------------------------------------------------- |
| 実装場所                               | Service Graph Connector（パターン、Transform、識別ルールなど）          | `cmdb_ci_nic` などに After Insert/Update BR/Flow                    | Scheduled Script / Flow で NIC/IP をコピー生成          | Management IP フィールドの Dictionary（Ref qualifier）                 |
| 実現イメージ                             | SGC が最初から「Linux Server にも NIC/IP を作る」ように変更               | SGCが作った NIC を VM から Linux に**移動**                                | SGCが作った VM側 NIC/IP はそのまま、Linux 用に**ミラー**を作成      | IPデータは一切いじらず、「参照候補として見える範囲」だけ拡張                                |
| CI IPs の状態                         | Linux 側に正しく表示される（理想的）                                    | Linux 側に表示される。VM 側からは NIC/IP が消える                                | Linux 側にも表示される。VM 側にも元データが残る                     | 変化なし（Linux の CI IPs は空のままでもよい前提）                               |
| Management IP への影響                 | 管理IP候補に Linux 配下のIPが普通に出る。特別な工夫不要                        | 同上。Linux に移動したIPが候補になる                                           | 同上。Linux 用に作ったIPが候補になる                           | **Linux＋関連VMの IP が候補に出るようになる**（目的直撃）                           |
| データ構造の「きれいさ」                       | ◎：最初から正しいモデル。VM/LINUX/NIC/IPが一貫                          | △：毎回 SGC が VM に付ける → BRがLinuxに移すという綱引き                           | ○：OOBモデルは維持しつつ、Linux向けのコピーを追加                    | ○：データ構造には手を入れない。ビュー（検索条件）だけ変える                                 |
| データ量                               | NIC/IP は必要最低限。理論上最もスマート                                  | 既存NICを流用するので増えない                                                 | NIC/IP が2系統になる（VM用＋Linux用）分だけ増加                  | 一切増えない                                                         |
| SGC/IRE との相性                       | **要注意**：識別ルールやTransformを誤ると重複CI・障害の元。Storeアップデート時もマージが必要 | 識別キー（object_id 等）を壊さなければ重複は基本発生しないが、毎回「VMに戻す→BRでLinuxに移す」のループになる | IREをバイパスして insert するため、識別ルールを理解した上で実装しないと重複CIリスク | SGC/IREには全く手を触れないので **最も安全**                                   |
| Azure 以外（AWS/オンプレ）への影響             | 設計を慎重にしないと他コネクタに波及し得る                                    | BR条件を `discovery_source='SG-Azure'` にすれば限定可能                     | 同上。条件でAzureだけを対象にできる                             | 判定条件で `discovery_source='SG-Azure'` のときだけ新クエリ、それ以外は従来クエリにすればOK |
| アップグレード（SGC更新）の影響                  | **大きい**：Storeアプリ更新でパターン/Transformが上書き→毎回コンフリクト対応の可能性     | 小〜中：SGCはOOBのままなので影響限定的。BRのテストのみで済むことが多い                          | 小〜中：同上。自作Job/Flowが動くか確認すればよい                     | **最小**：Ansible用フィールドの辞書1か所だけ。SGC更新の影響はほぼゼロ                     |
| プラットフォーム（バージョンアップ）の影響              | 中〜大：CI Class ModelやSGCの仕様変化の影響を受けやすい                     | 小：`cmdb_rel_ci`／`cmdb_ci_nic` に大変更がなければそのまま動く                    | 小：同上                                             | ごく小：フィールド定義が残っている限り、そのまま動く                                     |
| 開発工数・難易度                           | **高い**：Service Graph, IRE, Patterns の深い理解とテストが必須         | 中：BR/Flowで cmdb_rel_ci をたどり cmdb_ci を書き換えるだけ                     | 中〜やや高：コピー元/先の整合、重複チェックなどロジック多め                   | **低い**：Ref qualifier のスクリプト1本で完結                               |
| 運用・トラブルシュート                        | 問題が起きたとき「OOBかカスタムか」の切り分けが難しくなりがち                         | NICがどこに紐づくかを常に意識する必要あり（VM側から見えなくなる点の説明も必要）                       | 「どっちのIPが正？」という説明が必要。運用ドキュメントをきちんと整えないと混乱しやすい     | ロジックは単純で、障害時も「Ref qualifier を一旦元に戻す」だけで切り戻し可能                  |
| ベンダーサポートとの相性                       | SGC自体を改造していると、サポート範囲外扱いになりやすい                            | 「取込後にBRでこう変えている」と説明すれば比較的理解されやすい                                 | 同上                                               | SGCは完全OOBのままなので、サポートを受けやすい                                     |
| 目的（Azure Linux の Mgmt IP 入力）のフィット感 | 目的は達成できるが「やりすぎ感」がある。大工事                                  | 目的は達成できるが、NIC移動という副作用が大きい                                        | 目的は達成。ただしデータ増 & 運用複雑化のトレードオフ                     | **目的にドンピシャ**：データは変えず、Azure Linux だけ VM側IPも選べるようになる             |

---

## ざっくりしたおすすめ

* **「とにかく運用とアップグレードの安定性を優先したい。今の要件は“管理IPを入れたい”だけ」**
  → **案D 一択**だと思います。

  * 今回作った `discovery_source='SG-Azure'` 判定＋`cmdb_rel_ci` 参照の Ref qualifier は、この前提にかなりきれいにハマっています。

* **「CMDB モデルもキレイに整えて、Linux の CI IPs にも必ずIPを持たせたい。将来的にCIからのレポートもガチでやる」**
  → 長期的には **案C（ミラーNIC/IP）** を検討する価値があります。

  * ただし、実装と運用ドキュメントはしっかり準備が必要。

* **案A（SGC/IREカスタム）** は、

  * 大規模なCMDB/Discoveryチームがいて、
  * 「Service Graphそのものを自社向けに作り込む」レベルの投資をする場合以外は、正直オーバーキルです。

* **案B（cmdb_ci書き換え）** は、

  * 早く効かせるには悪くないですが、
  * 今回のように「VM側の構造はなるべくいじりたくない & Mgmt IPだけ解決したい」なら、
    **案Dに完全に負けてしまう**ポジションかな、という印象です。

---

今の要件セット（Azure Linuxだけ拡張／AWSはそのまま／Ansible Mgmt IP優先）を見る限り、
**本番では案Dを採用して、必要になったら将来案Cを検討**という二段構えが一番バランス良いと思います。



ご指摘ありがとうございます。**仰る通りです。**

ユーザー様の技術的な分析（IREの挙動とIdentification Ruleに関する洞察）は非常に鋭く、正確です。
SGC-Azureの初期設定（OOB）において、NIC（`cmdb_ci_nic` や `cmdb_ci_network_adapter`）の識別ルールが「親CI (Hardware) に依存しない（Independent）」設定、つまり `object_id` や `mac_address` 単独で識別される設定であれば、**「別レコードとして雪だるま式に増える」という事象は発生しません。**

その代わり、ご懸念の通り\*\*「毎日、IREがVMに戻し、直後にBusiness RuleがServerに書き換える」という『綱引き（更新合戦）』\*\*が発生します。

この点を踏まえ、訂正した評価を含む4案の比較表を作成しました。
今回、**Ansibleタブでの入力エラー（無効な参照）を解決する** という目的において、**案D（参照制限の緩和）** を最有力として評価しています。

### 比較・検討表：Linux ServerへのIP紐づけ・入力方式

| 比較項目 | **案A：親の書き換え (Re-parent)** | **案B：同期コピー (Sync Copy)** | **案C：ETL直接修正** | **案D：参照制限の緩和 (Ref Qual)** |
| :--- | :--- | :--- | :--- | :--- |
| **概要** | BRでNICの親を `VM` → `Linux Server` に移動する。 | 元NICは `VM` に残し、`Linux Server` 用に**分身**を作る。 | ETLの設定を変え、最初から `Linux Server` に紐づける。 | データはいじらず、入力欄の**フィルタ条件**を変えてVMのIPを選べるようにする。 |
| **運用への影響**<br>(SGC-Azure実行時) | **× 毎日「更新合戦」が発生**<br>ご指摘の通り、レコード増殖は防げても、毎回のインポートで「VMに戻る⇔Serverに移る」の更新ループが走ります。<br>これにより**監査ログ(History Line)が爆発的に肥大化**し、DB容量とパフォーマンスを圧迫します。 | **○ 安定**<br>SGCはVM側のNICを更新し、BRが検知してServer側の分身に同期します。<br>更新がない日は何も起きません。 | **△ 識別エラーリスク**<br>Azureのデータ構造と乖離するため、もし識別ルールが厳密だとエラー(Skipped)になる可能性があります。 | **◎ 影響なし (完全分離)**<br>データの書き込み・更新処理には一切介入しません。<br>SGCの標準動作がそのまま保証されます。 |
| **アップグレード影響**<br>(ServiceNow VerUp) | **○ なし**<br>標準ロジックそのものは変更していないため、競合は発生しません。 | **○ なし**<br>標準ロジックは変更していません。 | **× 競合発生 (Skip)**<br>ETL定義をカスタマイズするため、SGC-Azureのバージョンアップ時に更新が適用されず、手動対応が必要です。 | **○ なし**<br>Dictionaryの設定変更だけなので、SGCやIREのコア機能には影響しません。 |
| **データの整合性・品質** | **△ ログが汚れる**<br>CMDBの更新履歴が「システムによる移動」で埋め尽くされます。<br>また、移動した一瞬の間は「VMにNICがない」状態になります。 | **△ データ重複**<br>同じIP/MACを持つNICが2つ存在することになります。<br>運用で「どっちが正？」と迷う可能性があります。 | **○ 理想的**<br>成功すれば最も綺麗ですが、技術的難易度が高いです。 | **◎ 正当な状態**<br>「インフラ(VM)がIPを持ち、OS(Server)がそれを利用する」というAzureのデータモデルを正しく反映しています。 |
| **Ansibleタブ対応**<br>(無効な参照エラー) | **解決**<br>自分の子供になるため、エラーは消えます。 | **解決**<br>自分の子供（分身）がいるため、エラーは消えます。 | **解決**<br>自分の子供になるため、エラーは消えます。 | **解決**<br>「VMのIPも選んでOK」と許可するため、エラーは消えます。 |
| **総合判定** | **× 非推奨**<br>(ログ肥大化・負荷懸念) | **△ 次点**<br>(データ重複が許容できれば可) | **△ 上級者向け**<br>(保守コスト大) | **◎ 最推奨 (Best Practice)**<br>(低リスク・高効果) |

-----

### 詳細解説：なぜ「案A」ではなく「案D」なのか

#### 案A（親の書き換え）の再評価：レコードは増えないが、ログが壊れる

ユーザー様のご指摘通り、識別ルールが適切であればレコード重複は回避できます。しかし、以下の「綱引き」はシステム運用上、非常に大きなデメリットとなります。

1.  **Sys\_audit / Sys\_history\_line テーブルの爆発:**
    毎日、全Linux Server台数分のNICに対して `update` が2回（IREによる書き戻し + BRによる再移動）発生します。数千台規模の場合、毎日数万件の不要な更新ログが積み上がり、テーブル容量を圧迫します。
2.  **「更新された」とみなされる:**
    実態（IPアドレスなど）が変わっていなくても、親の付け替えが発生するため、`sys_updated_on` が毎日更新されます。これにより、「長期間変更がないサーバーを探す」といったクエリが機能しなくなります。

#### 案D（参照制限の緩和）の優位性

今回判明した課題は **「Ansibleタブの管理IPアドレス欄でエラーが出る（入力できない）」** という点でした。
これに対し、案Dは\*\*「データの実体（VMにNICがある状態）は変えずに、ServiceNowに入力ルールだけを教え込む」\*\* アプローチです。

  * **IRE/ETLへの干渉ゼロ:** 取り込み処理には一切触れないため、最も安全です。
  * **根本解決:** 「VMのIPを使いたい」という要件に対し、データを無理やりコピーや移動させるのではなく、「参照できる範囲を広げる」のが本来のデータベース設計として正しいアプローチです。
  * **実装コスト:** 前回の回答にある「Script Include」と「Dictionary設定」だけで完了します。

### 結論

ご提示いただいた **「案A（親書き換え）」** は、レコード重複のリスクは低いものの、**「更新合戦によるログ肥大化・更新日時の常時更新」** という運用上の副作用が大きいため、やはりお勧めできません。

Ansibleタブへの入力エラー解消が主目的であれば、**「案D：参照制限の緩和（Reference Qualifierの変更）」** で進めることを強く推奨いたします。
